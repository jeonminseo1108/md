# md

# SNU CS M1522.00800 : System Programming - Sample Midterm Questions

We have prepared some practice problems related to linking that we have covered this week.  
These problems have been selected from those generated by **AI tools (Cramify and ChatGPT)**,  
based on your textbook content and previous exam questions.

There is no need to submit anything after reviewing this material,  
but we hope it will help you prepare for the upcoming midterm.  
Also, note that some problems may contain important concepts beyond linking.

---

We don't provide the answers to the sample midterm questions.  
Instead, engage in discussions with your peers to find the answers to each question.  
This will improve your understanding and better prepare you for the exam.

## Question 1.
Consider the following statement:  
True or False: If a variable is declared as “static” inside a source file, it can still be accessed from other source files if they are linked together during compilation.


## Question 2.
Consider the executable object file `a.out`, which is compiled and linked using the following command:  
`$ gcc800 -o a.out main.c foo.c`  
Files `main.c` and `foo.c` consist of the following code. What is the output of `a.out`?

```c
// main.c
#include <stdio.h>

static int a = 1;
int b = 2;
int c;

void foo();

int main(){
    int c = 3;

    foo();
    printf("a=%d, b=%d, c=%d\n", a, b, c);
    return 0;
}
```

```c
// foo.c
int a;
extern int b, c;

void foo(){
    a = 4;
    b = 5;
    c = 6;
}
```

## Question 3.
What is the best definition of static linking?  
- `A process that combines relocatable object files to form an executable object file.  `
- `A method of linking that occurs at run time.  `
- `A technique that allows for dynamic loading of libraries.  `
- `A process that resolves symbols at load time.`


## Question 4.
Which section in an ELF relocatable object file contains initialized global and static variables?  
- `.text`  
- `.rodata`  
- `.data`  
- `.bss`

## Qusetion 5. 
Consider the following two files that are compiled and linked together:

```c
/* file1.c */
#include <stdio.h>

int x = 10;

void foo();

int main() {
    printf("%d\n", foo());
    return 0;
}
```

```c
/* file2.c */
static int foo() {
    return 5;
}
```
True or False: The program will compile successfully and the output will be 5


## Qusetion 6. 
Given the following code:

```c
/* file1.c */
#include <stdio.h>

extern int x;
int main() {
    printf("%d\n", x);
    return 0;
}
```

```c
/* file2.c */
int x = 10;
```
If you compile and link these two files using `gcc -o a.out file1.c file2.c`, what is the expected output of the program?

- `Compile error`  
- `0`
- `10`
- `Undefined behavior`


# SNU CS M1522.00800 : System Programming - Sample Midterm Questions

We have prepared some practice problems for upcoming midterm.  
These problems have been selected and modified from those generated by **AI tools (Cramify and ChatGPT)**,  
based on your textbook content and previous exam questions.

The following problem is based on concepts from the CS:APP textbook (Chapters 7.0 - 7.15, 10.0 - 10.4, and 10.6 - 10.12).

There is no need to submit anything after reviewing this material,  
but we hope it will help you prepare for the upcoming midterm.  
Also, note that some problems may contain important concepts that go beyond what you have learned.

---

We don't provide the answers to the sample midterm questions.  
Instead, engage in discussions with your peers to find the answers to each question.
Of course, you may ask questions to the professor and TAs through the campuswire.
This will improve your understanding and better prepare you for the exam.

## Question 1.
Consider the C program below. For brevity, assume that we do not check error return codes, 
that is, all functions return normally. Also assume that we have included all the header files
we need. What is the output of the following program?

```c
// main.c
int main() {
    int fd1, fd2;
    char c;

    fd1 = open("input1.txt", O_RDONLY);
    if (fork() == 0) {
        read(fd1, &c, 1);
        close(fd1);
        exit(0);
    }

    wait(NULL);

    dup2(fd1, fd2);
    read(fd1, &c, 1);
    read(fd2, &c, 1);
    printf("read: %c\n", c);

    close(fd1);
    exit(0);
}
```


## Question 2.
Consider the C program below. For brevity, assume that we do not check error return codes, 
that is, all functions return normally. Also assume that we have included all the header files
we need. What is the output of the following program?

```c
// main.c
int main() {
    int fd1, fd2;
    char c1, c2;

    fd1 = open("input1.txt", O_RDONLY);

    read(fd1, &c1, 1);

    if (fork() == 0) {
        read(fd1, &c1, 1);
        exit(0);
    }

    wait(NULL);

    fd2 = open("input1.txt", O_RDONLY);

    read(fd1, &c1, 1);
    read(fd2, &c2, 1);

    printf("c1: %c\n", c1);
    printf("c2: %c\n", c2);

    close(fd1);
    close(fd2);
    exit(0);
}
```

## Question 3.
In this problem, let `REF(x.i) → DEF(x.k)` denote that the linker will associate an arbitrary reference 
to symbol `x` in module `i` to the definition of `x` in module `k`. 
For each example that follows, use this notation to indicate how the linker would resolve references 
to the multiply-defined symbol in each module. 
If there is a link-time error (rule 1), write "ERROR". 
If the linker arbitrarily chooses one of the definitions (rule 3), write "UNKNOWN".

#### A. 

```c
// module 1
int main()
{
}
```

```c
// module2
int main;
int p2()
{
}
```
(a) REF(main.1) → DEF(__________)

(b) REF(main.2) → DEF(__________)


#### B. 
```c
// module 1
int main()
{
}
```

```c
// module2
int main = 1;
int p2()
{
}
```
(a) REF(main.1) → DEF(__________)

(b) REF(main.2) → DEF(__________)

#### C. 
```c
// module 1
int main()
{
}
```

```c
// module2
int __attribute__((weak)) main;
int p2()
{
}
```
(a) REF(main.1) → DEF(__________)

(b) REF(main.2) → DEF(__________)

#### D. 
```c
// module 1
int __attribute__((weak)) main()
{
}
```

```c
// module2
#pragma weak main
int main;
int p2()
{
}
```
(a) REF(main.1) → DEF(__________)

(b) REF(main.2) → DEF(__________)


## Question 4.

#### A. 
Discuss the advantages of separating the `.bss` and `.data` sections in memory.

#### B. 
Explain the difference between internal fragmentation and external fragmentation.

#### C. 
Why is a multi-level page table used in memory management? Discuss its advantages and disadvantages.

#### D. 
Explain the difference between a page fault and a segmentation fault.


## Qusetion 5. 
Consider the call to the function `swap` in the object file `m.o`.

```assembly
9: e8 00 00 00 00      callq e <main+0xe>    swap()
```
with the following relocation entry:
```
r.offset = 0x10
r.symbol = func
r.type   = R_X86_64_PC32
r.addend = -6
```
Now suppose that the linker relocates .text in m.o to address 0x500500 and swap to address 0x500530.
What is the value of the relocated reference to swap in the callq instruction?



# SNU CS M1522.00800 : System Programming - Sample Midterm Questions

We have prepared some practice problems related to linking that we have covered this week.  
These problems have been selected from those generated by **AI tools (Cramify and ChatGPT)**,  
based on your textbook content and previous exam questions.

There is no need to submit anything after reviewing this material,  
but we hope it will help you prepare for the upcoming midterm.  
Also, note that some problems may contain important concepts beyond linking.

---

We don't provide the answers to the sample midterm questions.  
Instead, engage in discussions with your peers to find the answers to each question.  
This will improve your understanding and better prepare you for the exam.

## Question 1.
Determine if the following code is correct. If it's incorrect, fix it.

(a)
```c
#include <stdio.h>
#include <stdlib.h>

int main() {
    int *numbers = (int *)malloc(5);
    for (int i = 0; i < 5; i++) {
        numbers[i] = i * 2;
    }
    free(numbers);
    return 0;
}
```

(b)
```c
void function() {
    int *array = (int *)malloc(sizeof(int) * 10);
    for (int i = 0; i < 15; i++) {
        array[i] = i;
    }
    free(array);
}
```

(c)
```c
#include <stdio.h>
#include <stdlib.h>

void createArray() {
    int *array = (int *)malloc(10 * sizeof(int));
    for(int i = 0; i < 10; i++) {
        array[i] = i;
    }
}

int main() {
    createArray();
    return 0;
}
```

**Answer:**

(a)

Issue:  
The code malloc(5) allocates only 5 bytes of memory. However, we need enough memory to store 5 integers. Since an int typically occupies 4 bytes, we should allocate 5 * sizeof(int) bytes. The current code may cause undefined behavior due to insufficient memory allocation.


Correction:
```c
int *numbers = (int *)malloc(5 * sizeof(int));
```

(b)

Issue:  
The array array has been allocated memory for 10 integers (indices 0 to 9). However, the for-loop runs from i = 0 to i = 14, accessing indices 0 to 14, which exceeds the allocated memory and results in a buffer overflow.  
Also, it's good practice to check if malloc successfully allocated memory by verifying that array is not NULL.


Correction:
```c
void function() {
    int *array = (int *)malloc(sizeof(int) * 10);
    if (array == NULL) {
        // Handle memory allocation failure
        return;
    }
    for (int i = 0; i < 10; i++) {
        array[i] = i;
    }
    free(array);
}
```

(c)

Issue:  
The createArray function allocates memory using malloc but does not deallocate it with free. This results in a memory leak. Each time the function is called, more memory is consumed and not released.


Correction:
- Option 1: Free the memory within the function after use.
```c
void createArray() {
    int *array = (int *)malloc(10 * sizeof(int));
    for(int i = 0; i < 10; i++) {
        array[i] = i;
    }
    // Use the array as needed within the function
    free(array); // Deallocate memory
}
```
- Option 2: Return the allocated memory to the caller and free it in main.
```c
int* createArray() {
    int *array = (int *)malloc(10 * sizeof(int));
    for(int i = 0; i < 10; i++) {
        array[i] = i;
    }
    return array;
}

int main() {
    int *myArray = createArray();
    // Use the array as needed
    free(myArray); // Deallocate memory
    return 0;
}
```


## Question 2.
The following code is intended to read integers from a file and store them in a dynamically allocated linked list. Then, it prints the numbers and frees the allocated memory.

```c
#include <stdio.h>
#include <stdlib.h>

typedef struct Node {
    int data;
    struct Node *next;
} Node;

Node* read_numbers(FILE *file) {
    Node *head = NULL;
    Node *current = NULL;

    int num;
    while (fscanf(file, "%d", &num) != EOF) {
        Node *node = malloc(sizeof(Node));
        node->data = num;
        node->next = NULL;

        if (head == NULL) {
            head = current;
        } else {
            current->next = node;
        }
        current = node;
    }
    return head;
}

void print_numbers(Node *head) {
    Node *current = head;
    while (current != NULL) {
        printf("%d\n", current->data);
        current = current->next;
    }
}

int main() {
    FILE *file = fopen("numbers.txt", "r");
    Node *list = read_numbers(file);
    fclose(file);

    print_numbers(list);

    return 0;
}
```

(a) Identify any memory leaks or pointer issues in the code. Explain what the problems are.

(b) Modify the code to properly free all allocated memory after use.

(c) Explain the dynamic memory concepts being tested in this problem.

**Answer:**

(a)

Issue 1: Incorrect Initialization of head
- In the read_numbers function, the line if (head == NULL) { head = current; } is incorrect.
- At this point, current may not have been assigned yet or could be NULL.
- The head pointer should be assigned the newly created node, not current.

Issue 2: Memory Leak Occurs
- The dynamically allocated memory for each node in the linked list is not freed before the program exits.
- Without freeing the allocated memory, a memory leak occurs because the program consumes system resources without releasing them.
- Additionally, there is no error checking for the result of malloc, which might return NULL if memory allocation fails.

(b)

Modified read_numbers Function:
```c
Node* read_numbers(FILE *file) {
    Node *head = NULL;
    Node *current = NULL;

    int num;
    while (fscanf(file, "%d", &num) != EOF) {
        Node *node = malloc(sizeof(Node));
        if (node == NULL) {
            fprintf(stderr, "Memory allocation failed\n");
            exit(1);
        }
        node->data = num;
        node->next = NULL;

        if (head == NULL) {
            head = node; // Corrected line
        } else {
            current->next = node;
        }
        current = node;
    }
    return head;
}
```

Adding a Function to Free the List:
```c
void free_list(Node *head) {
    Node *current = head;
    while (current != NULL) {
        Node *next_node = current->next;
        free(current);
        current = next_node;
    }
}
```

Modified main Function:
```c
int main() {
    FILE *file = fopen("numbers.txt", "r");
    if (file == NULL) {
        fprintf(stderr, "Failed to open file\n");
        return 1;
    }
    Node *list = read_numbers(file);
    fclose(file);

    print_numbers(list);
    free_list(list); // Free the allocated memory

    return 0;
}
```

(c)

Proper Initialization and Use of Pointers:
- Assigning correct values to pointer variables.
- Managing data structures using pointers accurately.

Preventing Memory Leaks:
- Ensuring that all dynamically allocated memory is freed after use.
- Efficient management of system resources.

Managing Linked Lists:
- Creating and initializing a linked list.
- Traversing the list to perform operations (e.g., printing data).
- Properly freeing the entire list to release memory.

Error Handling:
- Checking the result of malloc for NULL to handle memory allocation failures.
- Verifying that the file was opened successfully before proceeding.

Dynamic Memory Management:
- Using malloc and free to allocate and deallocate memory at runtime.
- Understanding the importance of matching each malloc with a corresponding free.

## Question 3.
The following code is intended to create a dynamic 2D array (matrix) that stores integer values, assign values to each element, and then print the matrix. Fill in the blanks to make the program work correctly.

```c
#include <stdio.h>
#include <stdlib.h>

int main() {
    int rows = 3, cols = 3;
    int **matrix = ________;                            // Blank 1

    for (int i = 0; i < rows; i++) {
        matrix[i] = ________;                           // Blank 2
    }

    // Assign values to the matrix
    for (int i = 0; i ____ rows; i++) {                 // Blank 3
        for (int j = 0; j ____ cols; j++) {             // Blank 4
            matrix[i][j] = i * cols + j;
        }
    }

    // Print the matrix
    for (int i = 0; i ____ rows; i++) {                 // Blank 5
        for (int j = 0; j ____ cols; j++) {             // Blank 6
            printf("%d ", matrix[i][j]);
        }
        printf("\n");
    }

    // Free memory
    for (int i = 0; ________; i++) {                    // Blank 7
        ________                                        // Blank 8
    }
    ________                                            // Blank 9

    return 0;
}
```

**Answer:**
```c
#include <stdio.h>
#include <stdlib.h>

int main() {
    int rows = 3, cols = 3;
    int **matrix = malloc(rows * sizeof(int*));         // Blank 1

    for (int i = 0; i < rows; i++) {
        matrix[i] = malloc(cols * sizeof(int));         // Blank 2
    }

    // Assign values to the matrix
    for (int i = 0; i < rows; i++) {                    // Blank 3
        for (int j = 0; j < cols; j++) {                // Blank 4
            matrix[i][j] = i * cols + j;
        }
    }

    // Print the matrix
    for (int i = 0; i < rows; i++) {                    // Blank 5
        for (int j = 0; j < cols; j++) {                // Blank 6
            printf("%d ", matrix[i][j]);
        }
        printf("\n");
    }

    // Free memory
    for (int i = 0; i < rows; i++) {                    // Blank 7
        free(matrix[i]);                                // Blank 8
    }
    free(matrix);                                       // Blank 9

    return 0;
}
```

## Question 4.
Consider the C program below. For brevity, assume that we do not check error return values, 
that is, all functions return normally. Also assume that we have included all the header files
we need. What is the output of the following program?

```c
#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>

int main() {
  int fd1, fd2, fd3, fd4, fd5;
  char c;

  fd1 = open("file1.txt", O_RDWR | O_CREAT | O_TRUNC, 0644);
  write(fd1, "abcdefgh", 8);
  lseek(fd1, 0, SEEK_SET);

  fd2 = open("file2.txt", O_RDWR | O_CREAT | O_TRUNC, 0644);
  write(fd2, "12345678", 8);
  lseek(fd2, 0, SEEK_SET);

  fd3 = dup(fd1);
  fd4 = dup2(fd2, fd3); 
  fd5 = dup2(fd4, fd1);

  read(fd1, &c, 1); 
  printf("fd1: %c\n", c);

  read(fd2, &c, 1);
  printf("fd2: %c\n", c);

  read(fd3, &c, 1);
  printf("fd3: %c\n", c);

  read(fd4, &c, 1);
  printf("fd4: %c\n", c);

  read(fd5, &c, 1);
  printf("fd5: %c\n", c);

  lseek(fd5, 7, SEEK_SET);
  write(fd5, "XYZ", 3);

  lseek(fd2, 0, SEEK_SET);
  while (read(fd2, &c, 1) == 1) {
    printf("fd2: %c\n", c);
  }

  close(fd1);
  close(fd2);
  close(fd3);
  close(fd4);
  close(fd5);

  return 0;
}
```

**Answer:** 
```
fd1: 1
fd2: 2
fd3: 3
fd4: 4
fd5: 5
fd2: 1
fd2: 2
fd2: 3
fd2: 4
fd2: 5
fd2: 6
fd2: 7
fd2: X
fd2: Y
fd2: Z
```

## Question 5.
Consider the C program below. For brevity, assume that we do not check error return values, 
that is, all functions return normally. Also assume that we have included all the header files
we need. What is the output of the following program?

```c
#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>

int main() {
  int fd1, fd2, fd3, fd4;
  char c;

  fd1 = open("file1.txt", O_RDWR | O_CREAT | O_TRUNC, 0644);
  write(fd1, "abcdefgh", 8);
  lseek(fd1, 2, SEEK_SET);

  fd2 = open("file1.txt", O_RDWR);
  write(fd2, "123", 3);

  fd3 = dup(fd1);
  lseek(fd3, 5, SEEK_SET);
  
  fd4 = dup2(fd2, fd1);

  read(fd1, &c, 1); 
  printf("fd1: %c\n", c);

  read(fd2, &c, 1);
  printf("fd2: %c\n", c);

  read(fd3, &c, 1);
  printf("fd3: %c\n", c);

  read(fd4, &c, 1);
  printf("fd4: %c\n", c);

  lseek(fd4, 0, SEEK_SET);
  write(fd4, "XYZ", 3);

  lseek(fd3, 0, SEEK_SET);
  while (read(fd3, &c, 1) == 1) {
    printf("fd3: %c\n", c);
  }

  close(fd1);
  close(fd2);
  close(fd3);
  close(fd4);

  return 0;
}
```

**Answer:**
```
fd1: d
fd2: e
fd3: f
fd4: f
fd3: X
fd3: Y
fd3: Z
fd3: d
fd3: e
fd3: f
fd3: g
fd3: h
```

## Question 6.
Consider the C program below. For brevity, assume that we do not check error return values, 
that is, all functions return normally. Also assume that we have included all the header files
we need. What is the output of the following program?
Suppose the disk file input1.txt consists of the 10 ASCII characters abcdefghij.

```c
// main.c
int main() {
    int fd1, fd2;
    char c;

    fd1 = open("input1.txt", O_RDONLY);
    if (fork() == 0) {
        read(fd1, &c, 1);
        close(fd1);
        exit(0);
    }

    wait(NULL);

    dup2(fd1, fd2);
    read(fd1, &c, 1);
    read(fd2, &c, 1);
    printf("read: %c\n", c);

    close(fd1);
    exit(0);
}
```
**Answer:**
```
read: c
```

## Question 7.
In this problem, let `REF(x.i) → DEF(x.k)` denote that the linker will associate an arbitrary reference 
to symbol `x` in module `i` to the definition of `x` in module `k`. 
For each example that follows, use this notation to indicate how the linker would resolve references 
to the multiply-defined symbol in each module. 
If there is a link-time error (rule 1), write "ERROR". 
If the linker arbitrarily chooses one of the definitions (rule 3), write "UNKNOWN".

#### A. 

```c
// module 1
int main()
{
}
```

```c
// module2
int main;
int p2()
{
}
```
(a) REF(main.1) → DEF(__________)

(b) REF(main.2) → DEF(__________)


#### B. 
```c
// module 1
int main()
{
}
```

```c
// module2
int main = 1;
int p2()
{
}
```
(a) REF(main.1) → DEF(__________)

(b) REF(main.2) → DEF(__________)

#### C. 
```c
// module 1
int main()
{
}
```

```c
// module2
int __attribute__((weak)) main;
int p2()
{
}
```
(a) REF(main.1) → DEF(__________)

(b) REF(main.2) → DEF(__________)

#### D. 
```c
// module 1
int __attribute__((weak)) main()
{
}
```

```c
// module2
#pragma weak main
int main;
int p2()
{
}
```
(a) REF(main.1) → DEF(__________)

(b) REF(main.2) → DEF(__________)


**Answer:**
```
(A)
REF(main.1) → DEF(ERROR)
REF(main.2) → DEF(ERROR)

(B)
REF(main.1) → DEF(ERROR)
REF(main.2) → DEF(ERROR)

(C)
REF(main.1) → DEF(main.1)
REF(main.2) → DEF(main.1)

(D)
REF(main.1) → DEF(UNKNOWN)
REF(main.2) → DEF(UNKNOWN)

```


## Question 8.

#### A. 
Discuss the advantages of separating the `.bss` and `.data` sections in memory.

#### B. 
Explain the difference between internal fragmentation and external fragmentation.

#### C. 
Why is a multi-level page table used in memory management? Discuss its advantages and disadvantages.

#### D. 
Explain the difference between a page fault and a segmentation fault.

**Answer:**
```
(A) 
The `.bss` section stores uninitialized global and static variables, 
whereas the `.data` section stores initialized global and static variables. 
The primary advantage of separating them is that the `.bss` section does not need to be stored 
in the executable file, thus reducing the file size. Additionally, at runtime, 
the operating system can easily zero-initialize the `.bss` section. 
This separation also optimizes memory usage by allowing the `.bss` to be allocated only the necessary space in memory.

(B)
Internal fragmentation occurs when allocated memory blocks have unused space within them 
due to fixed block sizes, leading to wasted memory inside the allocated block. 
External fragmentation happens when free memory is divided into small non-contiguous blocks, preventing the allocation of large memory requests even though there may be enough total free memory, but it is scattered.

(C) 
A multi-level page table is used to reduce the memory overhead of storing page tables. 
Instead of storing a single large page table, it splits the table into multiple levels, 
only allocating memory for portions of the table that are actually in use. 

Advantages:
- Reduces memory consumption for page tables, especially in sparse address spaces.
- Allows better scalability with larger address spaces.

Disadvantages:
- Increases the number of memory accesses required for each translation, as each level of the page table must be traversed, which can result in slower performance.

(D) 
A page fault occurs when a program accesses a valid page that is not currently loaded in memory, typically resulting in the operating system loading the page from disk into memory. 
A segmentation fault, on the other hand, occurs when a program tries to access an invalid memory location or a memory region it does not have permission to access (e.g., reading/writing to an illegal address or violating access rights).


```

## Qusetion 9. 
Consider the call to the function `swap` in the object file `m.o`.

```assembly
9: e8 00 00 00 00      callq e <main+0xe>    swap()
```
with the following relocation entry:
```
r.offset = 0x10
r.symbol = func
r.type   = R_X86_64_PC32
r.addend = -6
```
Now suppose that the linker relocates .text in m.o to address 0x500500 and swap to address 0x500530.
What is the value of the relocated reference to swap in the callq instruction?

**Answer:**
```
0x1A
```
